// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/IonCannon.h"

#include "Commands/AimCamera.h"
#include "Commands/AimJoystick.h"
#include "frc/smartdashboard/SmartDashboard.h"
#include <sstream>

constexpr double kShooterMaxCurrent = 40.0;
constexpr double kTurretMaxCurrent = 20.0;


IonCannon::IonCannon() : frc::Subsystem("IonCannon") {

    shooterMotor1.reset(new rev::CANSparkMax(12, rev::CANSparkMax::MotorType::kBrushless));
    shooterMotor2.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    turretMotor.reset(new rev::CANSparkMax(14, rev::CANSparkMax::MotorType::kBrushless));
    domeServo.reset(new frc::Servo(5));
    AddChild("DomeServo", domeServo);

    turretReferenceSwitch.reset(new frc::DigitalInput(4));
    AddChild("TurretReferenceSwitch", turretReferenceSwitch);

    // Set up encoders
    shooter1Encoder.reset(new rev::CANEncoder(*shooterMotor1));
    turretQuadEncoder.reset(new rev::CANEncoder(*turretMotor));

    //loadedSensor.reset(new frc::DigitalInput(12));
    //AddChild("LoadedSensor", loadedSensor);

    // limit current
    shooterMotor1->SetSmartCurrentLimit(kShooterMaxCurrent);
    shooterMotor2->SetSmartCurrentLimit(kShooterMaxCurrent);
    turretMotor->SetSmartCurrentLimit(kTurretMaxCurrent);
    
    // Set the shooter motor follower
    shooterMotor2->Follow(*shooterMotor1);
 
    //uint32_t lcpr = shooter1Encoder->GetCountsPerRevolution();
    //shooter1Encoder->SetPositionConversionFactor(2.0 * wpi::math::pi * (double)kWheelRadius * kGearRatio / lcpr);
    //shooter1Encoder->SetPositionConversionFactor(1.0);

    // initialize to zero, range is +/- 90 degrees
    //turretQuadEncoder->SetPosition(0);
    
    //uint32_t tcpr = turretQuadEncoder->GetCountsPerRevolution();
    //turretQuadEncoder->SetPositionConversionFactor(2.0 * wpi::math::pi * (double)kTurretRadius * kTGearRatio / tcpr);
    //turretQuadEncoder->SetPositionConversionFactor(1.0);

    /**
     * In order to use PID functionality for a controller, a CANPIDController object
     * is constructed by calling the GetPIDController() method on an existing
     * CANSparkMax object
     * set PID coefficients
     */

    /**
     * The RestoreFactoryDefaults method can be used to reset the configuration parameters
     * in the SPARK MAX to their factory default state. If no argument is passed, these
     * parameters will not persist between power cycles
     */
    //m_motor.RestoreFactoryDefaults();
  // default velocity PID coefficients
  double kvP = 6e-5, kvI = 1e-6, kvD = 0, kvIz = 0, kvFF = 0.000015, kvMaxOutput = 1.0, kvMinOutput = -1.0;
    shooterPIDController.reset(new rev::CANPIDController(*shooterMotor1));
    shooterPIDController->SetP(kvP);
    shooterPIDController->SetI(kvI);
    shooterPIDController->SetD(kvD);
    shooterPIDController->SetIZone(kvIz);
    shooterPIDController->SetFF(kvFF);
    shooterPIDController->SetOutputRange(kvMinOutput, kvMaxOutput);

      // default Position PID coefficients
  double kpP = 0.1, kpI = 1e-4, kpD = 1, kpIz = 0, kpFF = 0, kpMaxOutput = 1, kpMinOutput = -1;
    turretPIDController.reset(new rev::CANPIDController(*turretMotor));
    turretPIDController->SetP(kpP);
    turretPIDController->SetI(kpI);
    turretPIDController->SetD(kpD);
    turretPIDController->SetIZone(kpIz);
    turretPIDController->SetFF(kpFF);
    turretPIDController->SetOutputRange(kpMinOutput, kpMaxOutput);


} 


void IonCannon::InitDefaultCommand() {

    //SetDefaultCommand(new AimCamera());
    SetDefaultCommand(new AimJoystick());
}

void IonCannon::Periodic() {

    AimCam();
    // Put code here to be run every loop
    frc::SmartDashboard::PutNumber("shooterSpd",shooter1Encoder->GetVelocity() );
    frc::SmartDashboard::PutNumber("turretPos",GetTurretPosition() );
    frc::SmartDashboard::PutNumber("domePos",GetDomePosition());
}

void IonCannon::AimCamPosition() {
    if (Robot::limeAide->getLimeRoxInView()) {
		double tx = Robot::limeAide->getLimeRoxX();
        double dx = GetTurretPosition() - (tx * kTurretXFactor);
        if (dx < kTurretLowLimit)
            dx = kTurretLowLimit;
        if (dx > kTurretHighLimit)
            dx = kTurretHighLimit;
        frc::SmartDashboard::PutNumber("target x",tx);
        frc::SmartDashboard::PutNumber("get turret position",GetTurretPosition());
        frc::SmartDashboard::PutNumber("set turret position",dx);

        //SetTurretPosition(dx);
    }
    else {
        frc::SmartDashboard::PutNumber("stop turret ", 0);
        AimStop();
    }
  
}

void IonCannon::AimCam() {
    float x = 0.;            // raw 0
    bool mMoving = false;

    if (Robot::limeAide->getLimeRoxInView()) {   
		double error = Robot::limeAide->getLimeRoxX(); 
		if (error > kCamTolerance) {
			double speed = kCamPower * error + kCamFriction;
			if (speed > kCamLimit)
				speed = kCamLimit;
			x = float(speed);
			//turretMotor->Set(x);
			mMoving = true;
		}
		else if (error < -kCamTolerance) {
			double speed = kCamPower * error - kCamFriction;
			if (speed < -kCamLimit)
				speed = -kCamLimit;
			x = float(speed);
			//turretMotor->Set(x);
			mMoving = true;
		}
		else {
			//turretMotor->Set(x);
			mMoving = false;
		    turretMotor->StopMotor();
		}
	}
	else {
			//SPAMutil::Log("CamDrive","No data",SPAMutil::LOG_INFO);
			turretMotor->StopMotor();
			mMoving = false;
	}	
  /* why does turretQuadEncoder->GetPosition() return -90?
    if (x > 0) {
        if (turretQuadEncoder->GetPosition() <= kTurretLowLimit)
            turretMotor->StopMotor();
            x = 0;
        //else
            //turretMotor ->Set(-x);
    }
    if (x < 0){
        if (turretQuadEncoder->GetPosition() >= kTurretHighLimit)
            turretMotor->StopMotor();
            x = 0;
        //else
            //turretMotor ->Set(-x);
    }
  */
    turretMotor ->Set(-x);
    frc::SmartDashboard::PutNumber("turretSpd",x );
	
}

// Shooter 
void IonCannon::SpinShooter(double speed)
{
    shooterMotor1->Set(speed);
}

void IonCannon::StopShooter()
{
    shooterMotor1->StopMotor();
}

void IonCannon::AimLeft()
{
    turretMotor->Set(-kTurretSpeed);
}
void IonCannon::AimRight()
{
    turretMotor->Set(kTurretSpeed);
}
void IonCannon::AimUp()
{
    domeServo->SetSpeed(kDomeSpeed);
}
void IonCannon::AimDown()
{
    domeServo->SetSpeed(-kDomeSpeed);
}

void IonCannon::SetServo(float value){
    m_domeServo = value / 2 + 0.5;
    domeServo->Set(m_domeServo);
}

void IonCannon::AimStop()
{
    turretMotor->StopMotor();
    domeServo->StopMotor();
}
void IonCannon::StopTurret()
{
        turretMotor->StopMotor();
}

void IonCannon::StopDome()
{
        domeServo->StopMotor();
}

// Burn CANSparkMAX settings on motors
void IonCannon::Burn()
{
    shooterMotor1->BurnFlash();
    shooterMotor2->BurnFlash();
    turretMotor->BurnFlash();
}

double IonCannon::GetTurretPosition()
{
    double pos = turretQuadEncoder->GetPosition();

    std::stringstream ss;
    ss << "GetTurretPosition() == " << pos << std::endl;
    SPAMutil::Log("IonCannon", ss.str().c_str(), SPAMutil::LOG_DBG);

    return pos;
}

void IonCannon::SetTurretPosition(double position)
{
    std::stringstream ss;
    ss << "SetTurretPosition(" << position << ")" << std::endl;
    SPAMutil::Log("IonCannon", ss.str().c_str(), SPAMutil::LOG_DBG);

    turretQuadEncoder->SetPosition(position);
}

double IonCannon::GetDomePosition()
{
    double pos = domeServo->GetPosition();

    std::stringstream ss;
    ss << "GetDomePosition() == " << pos << std::endl;
    SPAMutil::Log("IonCannon", ss.str().c_str(), SPAMutil::LOG_DBG);

    return pos;
}


static void SetPidStuff()
{
        // read setpoint from joystick and scale by max rpm

// velocity PID
/*
    double SetPoint = 0.0;// = MaxRPM*m_stick.GetY();
    if (m_stick.GetRawButton(1)) {
      SetPoint = 100;
    } else if (m_stick.GetRawButton(2)) {
      SetPoint = 500;
    } else if (m_stick.GetRawButton(3)) {
      SetPoint = 750;
    } else if (m_stick.GetRawButton(4)) {
      SetPoint = 2500;
    } else {
      SetPoint = 0;
    }
    */
    /**
     * PIDController objects are commanded to a set point using the 
     * SetReference() method.
     * 
     * The first parameter is the value of the set point, whose units vary
     * depending on the control type set in the second parameter.
     * 
     * The second parameter is the control type can be set to one of four 
     * parameters:
     *  rev::ControlType::kDutyCycle
     *  rev::ControlType::kPosition
     *  rev::ControlType::kVelocity
     *  rev::ControlType::kVoltage
     */
    
    //m_pidController.SetReference(SetPoint, rev::ControlType::kVelocity);

    //frc::SmartDashboard::PutNumber("SetPoint", SetPoint);
    //frc::SmartDashboard::PutNumber("ProcessVariable", m_encoder.GetVelocity());
    

}

static void anotherone()
{
      // Position PID coefficients
  double kP = 0.1, kI = 1e-4, kD = 1, kIz = 0, kFF = 0, kMaxOutput = 1, kMinOutput = -1;

    /**
     * The RestoreFactoryDefaults method can be used to reset the configuration parameters
     * in the SPARK MAX to their factory default state. If no argument is passed, these
     * parameters will not persist between power cycles
     */
    //m_motor.RestoreFactoryDefaults();

    /**
     * PIDController objects are commanded to a set point using the 
     * SetReference() method.
     * 
     * The first parameter is the value of the set point, whose units vary
     * depending on the control type set in the second parameter.
     * 
     * The second parameter is the control type can be set to one of four 
     * parameters:
     *  rev::ControlType::kDutyCycle
     *  rev::ControlType::kPosition
     *  rev::ControlType::kVelocity
     *  rev::ControlType::kVoltage
     */
    //m_pidController.SetReference(rotations, rev::ControlType::kPosition);
    
    //frc::SmartDashboard::PutNumber("SetPoint", rotations);
    //frc::SmartDashboard::PutNumber("ProcessVariable", m_encoder.GetPosition());



}