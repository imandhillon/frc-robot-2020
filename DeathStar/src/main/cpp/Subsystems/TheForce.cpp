// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/TheForce.h"
#include "Commands/Gravitate.h"
#include "ntcore.h"
#include "frc/smartdashboard/SmartDashboard.h"
#include <algorithm>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

TheForce::TheForce() : frc::Subsystem("TheForce") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  liftMotor.reset(new ctre::phoenix::motorcontrol::can::WPI_VictorSPX(6));
  liftMotor1.reset(new ctre::phoenix::motorcontrol::can::WPI_VictorSPX(7));

  liftEncoder.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
  AddChild("LiftEncoder", liftEncoder);
  liftEncoder->SetDistancePerPulse(1.0);
  //liftEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);
  liftEncoder->SetPIDSourceType(frc::PIDSourceType::kDisplacement);
  liftReferenceSwitch.reset(new frc::DigitalInput(11));
  AddChild("LiftReferenceSwitch", liftReferenceSwitch);

  liftMotor1->Follow(*liftMotor);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  m_BangBang_Speed   =  0.750;
  m_LiftSetPoint     =  0.;
  m_kminInput        =  0.;
  m_kmaxInput        = 1500.;
  m_kmaxOutput       =  1.;
}

void TheForce::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
     //SetDefaultCommand(new Gravitate(0.));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void TheForce::Periodic() {
    // Put code here to be run every loop
    frc::SmartDashboard::PutNumber("TheForce", liftEncoder->GetDistance());
    //if(theForceEnabled)
    //YodaLift();
    if(theForceEnabled)
       ChewieLift();
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

void TheForce::UseTheForce(std::shared_ptr<frc::Joystick> j)
{
    //float x = j->GetX(4);            // raw 0
    float y = j->GetRawAxis(5);            // raw 1
    if(y > 0.5){
        y = 0.5;
    }

    if(y < -0.5){
        y = -0.5;
    }
    liftMotor->Set(y);
    //differentialDrive->TankDrive(-y, -y, true);
}
void TheForce::YodaLift()
{
	   double lSetPoint;
	   double lEncVal;
	   double lJoyX ;
	   double lError ;
	   
	   // setPtFore is set by SetAngleFore in MoveWheel
	   lSetPoint = m_LiftSetPoint;

// allow a vernier
        std::shared_ptr<frc::Joystick> joyy = Robot::oi->getDriverJoystick();
        double vernyY = -(joyy->GetRawAxis(5));	
        vernyY *= 10.;

        lSetPoint += vernyY;

	   lEncVal = liftEncoder->GetDistance();
	   // lError in encoder counts
	   lError = lSetPoint - lEncVal;
	   if(lError < BANGBANG_LO_SIDE)     // low side of deadband
	   {
		   lJoyX =  1. * m_BangBang_Speed;
	   }
	   else if(lError > BANGBANG_HI_SIDE) // hi side of deadband
	   {
		   lJoyX = -1. * m_BangBang_Speed ;
	   }
	   else
	   {
		   lJoyX = 0.0 ;     // in deadband
	   }
	   liftMotor->Set(lJoyX);
	   
}
void TheForce::SetLiftWookie() // max
{
    //m_LiftSetPoint = WOOKIE_HEIGHT;
    if (m_kmaxInput > m_kminInput) {
      m_LiftSetPoint = std::clamp(WOOKIE_HEIGHT, m_kminInput, m_kmaxInput);
    } else {
      m_LiftSetPoint = WOOKIE_HEIGHT;
    }
}
void TheForce::SetLiftEwok()   // home
{
    //m_LiftSetPoint = EWOK_HEIGHT;
    if (m_kmaxInput > m_kminInput) {
      m_LiftSetPoint = std::clamp(EWOK_HEIGHT, m_kminInput, m_kmaxInput);
    } else {
      m_LiftSetPoint = EWOK_HEIGHT;
    }   
}
void TheForce::SetLiftSolo()   // hang
{
    // allow a vernier
    std::shared_ptr<frc::Joystick> joyy = Robot::oi->getDriverJoystick();
    double vernyY = -(joyy->GetRawAxis(5));	
    vernyY *= 50.;
       
    double aLiftSetPoint = SOLO_HEIGHT + vernyY;
    if (m_kmaxInput > m_kminInput) {
      m_LiftSetPoint = std::clamp(aLiftSetPoint, m_kminInput, m_kmaxInput);
    } else {
      m_LiftSetPoint = aLiftSetPoint;
    }
       
}

     void TheForce::SetLiftHome()   // hang
    {
       m_LiftSetPoint = 5.;
    }
    void TheForce::SetLiftBangBang(double height, double speed)
    {
        m_BangBang_Speed = speed;
        m_LiftSetPoint = height;
    }

    void TheForce::ChewieLift()
    {
        double pos = m_LiftSetPoint;    

        // allow a vernier
        //std::shared_ptr<frc::Joystick> joyy = Robot::oi->getDriverJoystick();
        //double vernyY = -(joyy->GetRawAxis(5));	
        //vernyY *= 10.;
        double vernyY = 0.;
       
        pos  +=  vernyY;

        const auto liftOutput = 
                   m_liftPIDController.Calculate(liftEncoder->GetDistance(), pos);
        
        double anOutput = std::clamp(liftOutput, -m_kmaxOutput, m_kmaxOutput);
 
        liftMotor->Set(-1. * anOutput);
    }

    void TheForce::GetPosition()
    {
        m_aPosition = (double)liftEncoder->GetDistance();
    }

/*
void TheForce::::PidControl()
{
    // display PID coefficients on SmartDashboard
    frc::SmartDashboard::PutNumber("P Gain", kpP);
    frc::SmartDashboard::PutNumber("I Gain", kpI);
    frc::SmartDashboard::PutNumber("D Gain", kpD);
    frc::SmartDashboard::PutNumber("I Zone", kpIz);
    frc::SmartDashboard::PutNumber("Feed Forward", kpFF);
    frc::SmartDashboard::PutNumber("Max Output", kpMaxOutput);
    frc::SmartDashboard::PutNumber("Min Output", kpMinOutput);
    frc::SmartDashboard::PutNumber("Set Rotations", 0);

    // read PID coefficients from SmartDashboard
    double p = frc::SmartDashboard::GetNumber("P Gain", 0);
    double i = frc::SmartDashboard::GetNumber("I Gain", 0);
    double d = frc::SmartDashboard::GetNumber("D Gain", 0);
    double iz = frc::SmartDashboard::GetNumber("I Zone", 0);
    double ff = frc::SmartDashboard::GetNumber("Feed Forward", 0);
    double max = frc::SmartDashboard::GetNumber("Max Output", 0);
    double min = frc::SmartDashboard::GetNumber("Min Output", 0);

    // if PID coefficients on SmartDashboard have changed, write new values to controller
    if((p != kpP)) { turretPIDController->SetP(p); kpP = p; }
    if((i != kpI)) { turretPIDController->SetI(i); kpI = i; }
    if((d != kpD)) { turretPIDController->SetD(d); kpD = d; }
    if((iz != kpIz)) { turretPIDController->SetIZone(iz); kpIz = iz; }
    if((ff != kpFF)) { turretPIDController->SetFF(ff); kpFF = ff; }
    if((max != kpMaxOutput) || (min != kpMinOutput)) {
      m_liftPIDController->SetOutputRange(min, max);
      kpMinOutput = min; kpMaxOutput = max;
    }

    // read setpoint from joystick and scale by max rpm
    //double SetPoint = 0.0;// = MaxRPM*m_stick.GetY();
    double SetPoint = frc::SmartDashboard::GetNumber("SetPoint", 0.0);


    m_liftPIDController->SetReference(SetPoint, rev::ControlType::kVelocity);

    frc::SmartDashboard::PutNumber("SetPoint", SetPoint);
    frc::SmartDashboard::PutNumber("ProcessVariable", liftEncoder->GetVelocity());

}
*/